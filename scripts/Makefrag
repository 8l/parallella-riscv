# Do not run directly!
# It is sourced by each board's subdirectory

base_dir = $(abspath ..)

default: $(BOARD_NAME)_bitstream


#
# ---------------------------------
# RISC-V Rocket Cores and Toolchain
# ---------------------------------
#

riscv_emulator:
	${SCRIPTS}/setup.rocketchip.submodule.sh
	# Build the Rocket Chip emulator
	cd ${ROCKETCHIP}/emulator && \
	make -j${JOBS}

riscv_rocketcore:
	${SCRIPTS}/setup.rocketchip.submodule.sh
	# Build the Rocket Chip Verilog RTL (for FPGAs)
	export FPGAConfig="DefaultFPGAConfig" && \
	export RocketCoreIPName="RISCV_Rocket_Core_RV64G_1.0" && \
	cd ${ROCKETCHIP}/fsim && \
	make verilog CONFIG=${FPGAConfig} && \
	make verilog MODEL=ZynqAdapter CONFIG=${FPGAConfig} && \
	cp generated-src/Top.${FPGAConfig}.v ${TOP}/ip/${RocketCoreIPName}/src/RV64G.Core.v && \
	cp generated-src/ZynqAdapter.${FPGAConfig}.v ${TOP}/ip/${RocketCoreIPName}/src/RV64G.HostIO.Adapter.v

riscv_toolchain:
	${SCRIPTS}/setup.rocketchip.submodule.sh
	# Install necessary packages (Ubuntu)
	sudo apt-get install autoconf automake autotools-dev curl \
	libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex \
	texinfo gperf libtool patchutils bc
	# Build the RISC-V Toolchain (Newlib version for use without an OS)
	cd ${ROCKETCHIP}/riscv-tools && git submodule update --init --recursive && \
	sed -i "s/JOBS=\([0-9]\{\0,2\}\)/JOBS=${JOBS}/g" build.common && \
	./build.sh && sed -i "s/JOBS=${JOBS}/JOBS=16/g" build.common


#
# -------------------------------------------
# IP, System Project and Bitstream Generation
# -------------------------------------------
#

fpga_dir = $(base_dir)/$(BOARD_NAME)/fpga

parallella_bitstream = $(fpga_dir)/parallella.bit.bin
$(parallella_bitstream): bitstream
	# Make final Parallella bitstream image (bin instead of bit)
	cd $(fpga_dir) && bootgen -image bit2bin.bif -split bin
	cd $(fpga_dir) && mv parallella_riscv.bit.bin parallella.bit.bin
	cd $(fpga_dir) && rm bit2bin.bin
parallella_bitstream: $(parallella_bitstream)

zedboard_bitstream: bitstream

bitstream = $(fpga_dir)/$(BOARD_NAME)_riscv.bit
$(bitstream): $(BOARD_NAME)_ip_deps $(fpga_dir)/system_params.tcl
	cd $(fpga_dir) && vivado -mode tcl -source $(fpga_dir)/system_bitstream.tcl;
	cd $(fpga_dir) && cp ./$(BOARD_NAME)_riscv/system.runs/impl_1/system_wrapper.bit ./$(BOARD_NAME)_riscv.bit
bitstream: $(bitstream)

system_project = $(fpga_dir)/$(BOARD_NAME)_riscv/system.xpr
$(system_project): $(BOARD_NAME)_ip_deps $(fpga_dir)/system_params.tcl
	cd $(fpga_dir) && rm -rf $(BOARD_NAME)_riscv
	cd $(fpga_dir) && vivado -mode tcl -source $(fpga_dir)/system_project.tcl;
system_project: $(system_project)

parallella_ip_deps: parallella_ip_package riscv_ip_package
zedboard_ip_deps: riscv_ip_package

parallella_ip_package = $(fpga_dir)/parallella_base/parallella_base.xpr
$(parallella_ip_package): $(fpga_dir)/ip_params_parallella.tcl
	cd $(fpga_dir) && rm -rf parallella_base
	cd $(fpga_dir) && vivado -mode tcl -source $(fpga_dir)/ip_package_parallella.tcl
parallella_ip_package: $(parallella_ip_package)

riscv_ip_package = $(fpga_dir)/riscv_rv64g/riscv_rv64g.xpr
$(riscv_ip_package): $(fpga_dir)/ip_params_riscv.tcl
	cd $(fpga_dir) && rm -rf riscv_rv64g
	cd $(fpga_dir) && vivado -mode tcl -source $(fpga_dir)/ip_package_riscv.tcl
riscv_ip_package: $(riscv_ip_package)

system_bd_update:
	cd $(fpga_dir) && sed -i "s/\(set scripts_vivado_version \)[0-9]\{4\}\.[0-9]/\1${VIVADO_VERSION}/" system_bd.tcl


#
# ----------------------------
# Platform software generation
# ----------------------------
#

arm_linux_dir = $(base_dir)/boot/$(LINUX_REPO)

uboot_dir = $(base_dir)/boot/$(UBOOT_REPO)

dtc_dir = $(base_dir)/boot/dtc

boot_build_dir = output/boot

final_output_dir = output/final

boot-bin: arm-uboot-$(BOARD_NAME) arm-linux arm-dtb
	cd $(boot_build_dir)
	ln -s ../../fpga/bitstream.bit .
	bootgen -image bit2bin.bif -o boot.bin
	cd $(final_output_dir)
	cp ../boot/boot.bin .

arm-linux: arm-uboot-$(BOARD_NAME) # Must first build uboot because we need its tools
	# Compile kernel
	git submodule update --init $(arm_linux_dir)
	# No make clean included here since one copy of linux should work on all boards
	cd $(arm_linux_dir) && make ARCH=arm CROSS_COMPILE=arm-xilinx-linux-gnueabi- $(LINUX_CONFIG)_defconfig
	cd $(arm_linux_dir) && make ARCH=arm CROSS_COMPILE=arm-xilinx-linux-gnueabi- -j${JOBS}
	# convert zImage to uImage
	cd $(arm_linux_dir) && export PATH=$(uboot_dir)/tools:$$PATH && make ARCH=arm CROSS_COMPILE=arm-xilinx-linux-gnueabi- UIMAGE_LOADADDR=0x8000 uImage
	mkdir -p $(final_output_dir)
	cp $(arm_linux_dir)/arch/arm/boot/uImage $(final_output_dir)/

arm-uboot-parallella: arm-uboot
arm-uboot-zedboard: arm-dtc arm-uboot # We need dtc to build ZedBoard's U-Boot from upstream u-boot-xlnx repo

arm-uboot:
	# Compile board-compatible u-boot
	git submodule update --init $(uboot_dir)
	# Copy relevant configuration files
	cp uboot/$(UBOOT_CONFIG).h $(uboot_dir)/include/configs/
	# Configure U-Boot
	cd $(uboot_dir) && make CROSS_COMPILE=arm-xilinx-linux-gnueabi- $(UBOOT_CONFIG)_defconfig
	# Build U-Boot but first unset LD_LIBRARY_PATH that points to Xilinx libraries in order to not break the U-Boot Build
	export PATH=$(dtc_dir):$$PATH && export LD_LIBRARY_PATH= && cd $(uboot_dir) && make CROSS_COMPILE=arm-xilinx-linux-gnueabi- -j${JOBS}
	mkdir -p $(boot_build_dir)
	cp $(uboot_dir)/u-boot $(boot_build_dir)/u-boot.elf

arm-dtc:
    # Compile device tree compiler (needed by upstream U-Boot for ZedBoard)
	git submodule update --init $(dtc_dir)
	cd $(dtc_dir) && make -j${JOBS}

arm-dtb:
	export PATH=$(arm_linux_dir)/scripts/dtc:$$PATH && dtc -I dts -O dtb -o $(final_output_dir)/devicetree.dtb dts/$(LINUX_DTS).dts

#
# ---------------------
# Handle ramdisk images
# ---------------------
#

ramdisk-open:
	mkdir ramdisk
	dd if=$(output_delivery)/uramdisk.image.gz  bs=64 skip=1 | \
	gunzip -c | sudo sh -c 'cd ramdisk/ && cpio -i'

ramdisk-close: arm-uboot # must first build uboot because we need tools
	@if [ ! -d "ramdisk" ]; then \
		echo "No ramdisk to close (use make ramdisk-open first)"; \
		exit 1; \
	fi
	sh -c 'cd ramdisk/ && sudo find . | sudo cpio -H newc -o' | gzip -9 > uramdisk.cpio.gz
	mkimage -A arm -O linux -T ramdisk -d uramdisk.cpio.gz $(output_delivery)/uramdisk.image.gz
	rm uramdisk.cpio.gz
	@echo "Don't forget to remove ramdisk before opening it again (sudo rm -rf ramdisk)"

clean:

.PHONY: clean
